{"mappings":"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","sources":["src/ios.tile.ts","src/iso.prism.ts","src/iso.input.ts","src/index.ts","src/iso.ts","src/iso.utils.ts","src/ios.person.ts"],"sourcesContent":["import { Entity, MapPosition, ScreenPosition, TileMap } from './iso'\n\nexport class Tile implements Entity { \n\n    constructor( public screenPos:ScreenPosition, private mapPos:MapPosition, private map:TileMap) {\n        console.log( `screen: [${this.screenPos.x},${this.screenPos.y}} - map:[${this.mapPos.x},${this.mapPos.y}]`)\n    }\n\n    render():void {\n        const  { x, y } = this.screenPos // topRight\n        const  { x: x0, y: y0 } = this.map.getTilePos(this.screenPos) // bottomLeft\n        \n        const { context, tile: {width, height, color } } = this.map\n\n        const cx = x - width / 2\n        const cy = y + height / 2\n\n        // begin\n        context.beginPath()\n\n        // move to start point\n        context.moveTo(cx, y)\n\n        /**\n         * create four lines\n         * --------------------------------------------\n         *    step 1  |  step 2  |  step 3  |  step 4\n         * --------------------------------------------\n         *    /       |  /       |  /       |  /\\  \n         *            |  \\       |  \\/      |  \\/\n         * --------------------------------------------\n         */\n        context.lineTo(x0, cy)\n        context.lineTo(cx, y0)\n        context.lineTo(x, cy)\n        context.lineTo(cx, y)\n\n        // draw path\n        context.stroke()\n\n\n        // fill tile\n        context.fillStyle = color\n        context.fill() \n    \n        // Debug\n\n        // context.beginPath()\n        // context.rect( x0, y, width, height)\n        // context.stroke()\n\n        context.fillStyle = 'black'\n        context.fillText( `${this.mapPos.x},${this.mapPos.y}`, x - 40, y + 20 )\n\n    }\n}","import { Entity, ScreenPosition, TileMap } from './iso'\n\n/**\n * \n */\nexport class Prism implements Entity {\n\n    /**\n     * \n     * @param x - map x position\n     * @param y - map y position\n     * @param map \n     */\n    constructor( public screenPos:ScreenPosition, private map:TileMap) {\n        console.log( 'prism', screenPos )\n    }\n\n    render() {\n        const {x,y} = this.screenPos\n\n        const { context, tile: {width, height, color } } = this.map\n\n        // top\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y - height)\n        context.lineTo(x - width, y - height / 2)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x - width / 2,  y - height)\n\n        context.fillStyle = '#555555'\n        context.fill()\n\n        // left\n        context.beginPath()\n\n        context.moveTo(x - width, y - height / 2)\n        context.lineTo(x - width, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x - width, y - height / 2)\n\n        context.fillStyle = '#444444'\n        context.fill()\n\n        // right\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n\n        context.fillStyle = '#777777'\n        context.fill()            \n    }\n}\n","import { ScreenPosition } from \"./iso\";\n\nexport type KeyBoardValue = 'ArrowLeft'|'ArrowUp'|'ArrowRight'|'ArrowDown'\n\n\nclass Key {\n    isDown = false;\n    isUp = true;\n    press?:() => void\n    release?: () => void\n    unsubscribe:() => void\n\n    constructor( private value:KeyBoardValue, target:EventTarget ) {\n\n        const downHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isUp && this.press) this.press()\n              this.isDown = true\n              this.isUp = false\n              event.preventDefault()\n            }\n          }\n        \n        const upHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isDown && this.release) this.release()\n              this.isDown = false\n              this.isUp = true\n              event.preventDefault()\n            }\n          }\n        \n        target.addEventListener( 'keydown', downHandler as EventListener, false )\n        target.addEventListener( 'keyup', upHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'keydown', downHandler as EventListener, false )\n            target.removeEventListener( 'keyup', upHandler as EventListener, false )\n    \n        }\n    }\n\n\n  \n}\n\nclass Mouse {\n    press?:( event:MouseEvent ) => void\n    up?: ( event:MouseEvent ) => void\n    move?: ( event:MouseEvent ) => void\n\n    unsubscribe:() => void\n\n    constructor( target:Element ) {\n\n        const downHandler = (event:MouseEvent) => {\n            if (this.press) this.press(event)\n            event.preventDefault()\n        }\n        \n        const upHandler = (event:MouseEvent) => {\n            if (this.up) this.up(event)\n            event.preventDefault()\n        }\n\n        const moveHandler = (event:MouseEvent) => {\n          if (this.move) this.move(event)\n          event.preventDefault()\n        }\n        \n        target.addEventListener( 'mousedown', downHandler as EventListener, false )\n        target.addEventListener( 'mouseup', upHandler as EventListener, false )\n        target.addEventListener( 'mousemove', moveHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'mousedown', downHandler as EventListener, false )\n            target.removeEventListener( 'mouseup', upHandler as EventListener, false )\n            target.removeEventListener( 'mousemove', moveHandler as EventListener, false )\n        }\n\n        \n    }  \n}\n\nexport const keyboard = ( value:KeyBoardValue, target:EventTarget = document ) => (new Key(value, target))\nexport const mouse = ( target:Element = document.body ) => (new Mouse(target))\n\n/**\n* \n* @param event \n* @returns \n*/\nexport function getMousePositionRelativeToTarget(event:MouseEvent):ScreenPosition|null {\n   const elem = event.target as Element|null;\n\n   if( elem == null ) return null\n\n   const rect = elem.getBoundingClientRect()\n\n   return {\n       x: event.clientX - rect.left,\n       y: event.clientY - rect.top\n   }\n}\n","import { MapParameters, TileMap, ScreenPosition } from './iso'\nimport { Prism } from './iso.prism'\nimport { Person } from './ios.person'\nimport { Image as ImageEntity } from './iso.image'\nimport { keyboard, mouse, getMousePositionRelativeToTarget } from './iso.input' \n\n// isometric map settings\nconst params:MapParameters = {\n    screen: { width: 1024, height: 800 },\n    mapSize: { width: 14, height: 14 },\n    tileSize: { width: 64, height: 32 }\n}\n\n// create map\nconst isoMap = new TileMap(params);\nisoMap.create();\nisoMap.loadImages( '/assets/man-ne.png', '/assets/man-nw.png', '/assets/man-se.png',' /assets/man-sw.png' )\n\n\nlet left = keyboard(\"ArrowLeft\"),\n      up = keyboard(\"ArrowUp\"),\n      right = keyboard(\"ArrowRight\"),\n      down = keyboard(\"ArrowDown\");\n\nconst _mouse = mouse()\n\n_mouse.press =  (event) => {\n        let pos = getMousePositionRelativeToTarget(event)\n\n        if( pos != null ) {\n            pos = isoMap.convertScreenToIso(pos) // adjust position on map\n                \n            isoMap.addEntity( new Prism( isoMap.convertIsoToScreen( pos ), isoMap) )\n        }\n}\n\n// const img = new ImageEntity('man-ne', isoMap.convertIsoToScreen( {x:1, y:0} ), isoMap )\n// isoMap.addEntity( img )\n\nconst person = new Person(  {x:1, y:1}, isoMap )\n\nisoMap.addEntity( person )\n\nleft.press = () => {\n    person.move = 'left'\n}\nleft.release = () => { \n    person.move = 'none'\n}\n\nright.press = () => {\n    person.move = 'right'\n}\nright.release = () => { \n    person.move = 'none'\n}\n\nup.press = () => {\n    person.move = 'up'\n}\nup.release = () => { \n    person.move = 'none'\n}\n\n\ndown.press = () => { \n    person.move = 'down'\n}\ndown.release = () => { \n    person.move = 'none'\n}\n","\nimport { basename } from './iso.utils'\nimport { Tile } from './ios.tile'\n\nexport type Position = {\n    x:number\n    y:number\n}\n\nexport type MapPosition = Position\nexport type ScreenPosition = Position\n\nexport type Size = {\n    width:number\n    height:number\n}\n\nexport type MapParameters = {\n    screen:Size\n    mapSize:Size\n    tileSize:Size\n    canvasId?:string\n    color?:string\n}\n\nexport interface Entity {\n    \n    screenPos:ScreenPosition\n\n    render():void\n}\n\nexport class TileMap implements Entity {\n\n    private _canvas:HTMLCanvasElement\n    context:CanvasRenderingContext2D\n    screenPos:ScreenPosition = {x:0, y:0}\n\n    screenSize:Size\n    mapSize:Size\n    tile:Size & { color:string }\n\n    mapPos:MapPosition\n\n    renderLayers:[ Array<Entity>, Array<Entity> ] = [  [], [] ]\n\n    gameLoopItnterval?:NodeJS.Timer\n\n    images = new Map<string,HTMLImageElement>()\n\n    /**\n     * @desc constructor\n     * @param object $params - initial parameters\n     */\n    constructor(params:MapParameters) {\n\n        const canvas = document.getElementById(params.canvasId ?? 'canvas') as HTMLCanvasElement|null\n\n        if( canvas == null ) throw new Error(\"canvas is null!\")\n        const context = canvas.getContext('2d')\n        if( context == null ) throw new Error(\"2d context from canvas is null!\")\n        \n        this._canvas = canvas\n        this.context = context\n    \n        // canvas area details\n        this.screenSize = { \n            width: params.screen.width,\n            height: params.screen.height\n            };\n\n        // size of isometric map\n        this.mapSize = {\n            width: params.mapSize.width,\n            height: params.mapSize.height\n        };\n\n        // size of single tile\n        this.tile = {\n            width: params.tileSize.width,\n            height: params.tileSize.height,\n            color: params.color ?? '#15B89A'\n        }\n\n        // initial position of isometric map\n        this.mapPos = { x:this.screenSize.width / 2, y: this.tile.height * 2 }\n        \n    }\n\n    /**\n     * \n     */\n    get canvas():HTMLCanvasElement {\n        return this._canvas\n    }\n\n    /**\n     * \n     * @returns \n     */\n    clear = () => this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    \n\n    /**\n     * @desc draw isometric map\n     */\n    create() {\n        // set canvas size\n        this._canvas.setAttribute('width', `${this.screenSize.width}`);\n        this._canvas.setAttribute('height', `${this.screenSize.height}`);\n\n        // tiles drawing loops\n        for (let x = 0; x < this.mapSize.width; x++) {\n            for ( let y = 0; y < this.mapSize.height; y++) {\n                this._addTile( {x:x, y:y } )\n            }\n        }\n        \n        this.gameLoopItnterval = setInterval( () => this.render(), 500 )\n    }\n\n    render():void {\n        this.clear()\n        this.renderLayers[0].forEach( v =>  v.render() )\n        this._sortLayer(1)\n        this.renderLayers[1].forEach( v =>  v.render() )\n\n    }\n    \n    /**\n     * @desc add a single tile to a layer\n     * @param int $x - position x on canvas area\n     * @param int $y - position y on canvas area\n     * @param layer \n     */\n    private _addTile = ( map:MapPosition, layer = 0):Tile => {\n        const screen = this.convertIsoToScreen( map) \n        const result = new Tile( screen, map, this )\n        this.renderLayers[layer].push( result )\n        return result\n    }\n\n    /**\n     * \n     * @param layer \n     * @returns \n     */\n    private _sortLayer = ( layer:number ) => \n        this.renderLayers[layer].sort( ($1,$2) => {\n            const dy = $1.screenPos.y - $2.screenPos.y \n            if( dy === 0 ) {\n                return $2.screenPos.x - $1.screenPos.x\n            }\n            return dy\n        })\n    \n\n    /**\n     * add single prism to a layer\n     * @param x - position x on canvas area\n     * @param y - position y on canvas area\n     * @param layer \n     */\n    addEntity = <T extends Entity>( entity:T, layer = 1 ):boolean =>  {\n\n        const map = this.convertScreenToIso(entity.screenPos)\n\n        if( this.isOnMap(map) ) {\n            this.renderLayers[layer].push( entity )\n            return true\n\n        }\n\n        return false\n    }\n\n    /**\n     * \n     * @param screen \n     * @returns \n     */\n    convertScreenToIso( screen:ScreenPosition ):MapPosition {\n        \n        const x = (screen.x - this.mapPos.x) / this.tile.width\n        const y = (screen.y - this.mapPos.y) / this.tile.height\n\n        return { \n            x: Math.floor(y + x), \n            y: Math.floor(y - x)  \n        }\n    }\n\n    /**\n     * \n     * @param map \n     * @returns \n     */\n    convertIsoToScreen = ( map:MapPosition ):ScreenPosition  => ({\n            x: ( (map.x-map.y) * this.tile.width / 2 ) + this.mapPos.x,\n            y: ( (map.x+map.y) * this.tile.height / 2 ) + this.mapPos.y\n        })\n\n    /**\n     * \n     * @param pos \n     * @returns \n     */\n    getTilePos = (pos:ScreenPosition):ScreenPosition => ({\n            x: pos.x - this.tile.width,\n            y: pos.y + this.tile.height\n        })\n\n    /**\n     * \n     * @param position \n     * @returns \n     */\n    isOnMap = (position:MapPosition):boolean  => \n            (position.x >= 0 && position.x < this.mapSize.width \n                && position.y >= 0 && position.y < this.mapSize.height) \n\n\n    /**\n     * \n     * @param path \n     * @returns \n     */\n    loadImages( ...paths: string[] )  {\n\n        paths.forEach( path => {\n            const name = basename(path)\n            \n            if( name ) {\n                let result = new Image()\n                result.src = path\n                result.onload = ( event:any ) => {\n                    console.log( `image ${name} from path: ${path} loaded`, event )\n                }\n                this.images.set( name, result)\n            }\n            else {\n                console.warn( `image path: ${path} is not valid!` )\n                // throw Error( `image path: ${path} is not valid!`)\n            }\n\n        })\n    }\n\n    renderImage( basename:string, screenPos:ScreenPosition ):void {\n        const source = this.images.get( basename )\n\n        if( source ) {\n            const { x, y } = this.getTilePos(screenPos)\n            this.context.drawImage( source, x, y - source!.naturalHeight )    \n        }\n    }\n \n}\n\n\n\n","/**\n * \n * @param path \n * @returns \n */\nexport const basename = ( path:string ):string|undefined => {\n    const elem = path.split(\"/\")\n    if( elem.length > 0 ) {\n        const last = elem[ elem.length - 1]\n        const result = /(.+)[.](.+)$/.exec(last)    \n        if( result != null ) {\n            return result[1]\n        }\n    }\n} \n    \n","import { Entity, ScreenPosition, MapPosition, TileMap } from './iso'\n\nexport class Person implements Entity {\n\n    move:'down'|'up'|'left'|'right'|'none' = 'none'\n    currentImage:string = 'man-se'\n    screenPos:ScreenPosition\n\n    constructor( public mapPos:MapPosition, private map:TileMap) {\n        this.screenPos = map.convertIsoToScreen( mapPos )\n    }\n\n    render():void {\n\n        switch( this.move ) {\n            case 'down':\n                \n                if( this.map.isOnMap( { x:this.mapPos.x+1,y:this.mapPos.y } ) ){\n                    this.mapPos.x +=1 \n                    this.currentImage = 'man-se'\n                }\n                break\n            case 'left':\n                if( this.map.isOnMap( { x:this.mapPos.x,y:this.mapPos.y+1} ) ){\n                    this.mapPos.y +=1 \n                    this.currentImage = 'man-sw'\n                }\n                break\n            case 'right':\n                if( this.map.isOnMap( { x:this.mapPos.x,y:this.mapPos.y-1 } ) ){\n                    this.mapPos.y -=1 \n                    this.currentImage = 'man-ne'\n                }\n                break\n            case 'up':\n                if( this.map.isOnMap( { x:this.mapPos.x-1,y:this.mapPos.y } ) ){                \n                    this.mapPos.x -=1 \n                    this.currentImage = 'man-nw'\n                    }\n                break\n        }\n        this.screenPos = this.map.convertIsoToScreen(this.mapPos)\n        this.map.renderImage(this.currentImage, this.screenPos )\n        \n    }\n}"],"names":["$2dd197c442f1bed314dd424b0db8422e$export$4cbd7057afcc19d","screenPos","mapPos","map","console","log","this","x","y","render","x0","y0","getTilePos","context","tile","width","height","color","cx","cy","beginPath","moveTo","lineTo","stroke","fillStyle","fill","fillText","$718fbb905372c26711d5aae570ddea86$export$c6ec6fa8b613b252","constructor","$f7a0ca685fc15ff0733c8744dc854746$var$Key","value","target","isDown","isUp","downHandler","event","key","press","preventDefault","upHandler","release","addEventListener","unsubscribe","removeEventListener","$f7a0ca685fc15ff0733c8744dc854746$var$Mouse","target1","downHandler1","upHandler1","up","moveHandler","move","$f7a0ca685fc15ff0733c8744dc854746$export$ea6328a15d7d48c9","value1","target2","document","$a4018e003ec9cbe06ab0cc0137aa4e69$var$isoMap","params","renderLayers","images","Map","clear","clearRect","canvas","_addTile","layer","screen","convertIsoToScreen","result","push","_sortLayer","sort","$1","$2","dy","addEntity","entity","convertScreenToIso","isOnMap","pos","position","mapSize","getElementById","canvasId","Error","getContext","_canvas","screenSize","tileSize","create","setAttribute","gameLoopItnterval","setInterval","forEach","v","Math","floor","loadImages","paths","path","name","elem","split","length","last","exec","$04b7f286a5ed5d84632c73262f84779c$export$6aeba2462e8c6a4","Image","src","onload","set","warn","renderImage","basename","source","get","drawImage","naturalHeight","$a4018e003ec9cbe06ab0cc0137aa4e69$var$left","$a4018e003ec9cbe06ab0cc0137aa4e69$var$up","$a4018e003ec9cbe06ab0cc0137aa4e69$var$right","$a4018e003ec9cbe06ab0cc0137aa4e69$var$down","body","$f7a0ca685fc15ff0733c8744dc854746$export$a2ffe625ade3af3c","rect","getBoundingClientRect","clientX","left","clientY","top","$f7a0ca685fc15ff0733c8744dc854746$export$13e93795cd93500c","$a4018e003ec9cbe06ab0cc0137aa4e69$var$person","currentImage"],"version":3,"file":"index.a62c5d6b.js.map"}