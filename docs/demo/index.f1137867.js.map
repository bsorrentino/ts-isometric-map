{"mappings":"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","sources":["src/isomap.ts","src/index.ts"],"sourcesContent":["\nexport namespace Iso {\n\n    export type MapPosition = {\n        x:number\n        y:number\n    }\n    \n    export type ScreenPosition = MapPosition\n\n    export type Size = {\n        width:number\n        height:number\n    }\n\n    export type MapParameters = {\n        screen:Size\n        map:Size\n        tile:Size\n        canvasId?:string\n        color?:string\n    }\n   \n    export interface Entity {\n        \n        mapPos:MapPosition\n        screenPos:ScreenPosition\n\n        render():void\n    }\n\n    class Tile implements Entity { \n\n        screenPos:Iso.ScreenPosition = {x:0, y:0}\n\n        constructor( public mapPos:MapPosition, private map:Map) {}\n    \n        render():void {\n            const { context, tile: {width, height, color } } = this.map\n    \n            // begin\n            context.beginPath()\n    \n            // move to start point\n            context.moveTo(this.mapPos.x - width / 2, this.mapPos.y)\n    \n            /**\n             * create four lines\n             * --------------------------------------------\n             *    step 1  |  step 2  |  step 3  |  step 4\n             * --------------------------------------------\n             *    /       |  /       |  /       |  /\\  \n             *            |  \\       |  \\/      |  \\/\n             * --------------------------------------------\n             */\n            context.lineTo(this.mapPos.x - width, this.mapPos.y + height / 2)\n            context.lineTo(this.mapPos.x - width / 2, this.mapPos.y + height)\n            context.lineTo(this.mapPos.x, this.mapPos.y + height / 2)\n            context.lineTo(this.mapPos.x - width / 2,  this.mapPos.y)\n    \n            // draw path\n            context.stroke()\n    \n            // fill tile\n            context.fillStyle = color\n            context.fill() \n             \n        }\n    }\n    class Prism implements Entity {\n\n        screenPos:ScreenPosition\n\n        /**\n         * \n         * @param x - map x position\n         * @param y - map y position\n         * @param map \n         */\n        constructor( public mapPos:MapPosition, private map:Map, screen?:ScreenPosition) {\n            \n            this.screenPos = ( screen ) ? screen : map.convertIsometricToScreen(mapPos)\n        }\n\n        render() {\n            const {x,y} = this.map.convertIsometricToScreen(this.mapPos)\n\n            const { context, tile: {width, height, color } } = this.map\n    \n            // top\n            context.beginPath()\n    \n            context.moveTo(x - width / 2, y - height)\n            context.lineTo(x - width, y - height / 2)\n            context.lineTo(x - width / 2, y)\n            context.lineTo(x, y - height / 2)\n            context.lineTo(x - width / 2,  y - height)\n    \n            context.fillStyle = '#555555'\n            context.fill()\n    \n            // left\n            context.beginPath()\n    \n            context.moveTo(x - width, y - height / 2)\n            context.lineTo(x - width, y + height / 2)\n            context.lineTo(x - width / 2, y + height)\n            context.lineTo(x - width / 2, y)\n            context.lineTo(x - width, y - height / 2)\n    \n            context.fillStyle = '#444444'\n            context.fill()\n    \n            // right\n            context.beginPath()\n    \n            context.moveTo(x - width / 2, y)\n            context.lineTo(x, y - height / 2)\n            context.lineTo(x, y + height / 2)\n            context.lineTo(x - width / 2, y + height)\n            context.lineTo(x - width / 2, y)\n    \n            context.fillStyle = '#777777'\n            context.fill()            \n        }\n    }\n\n    export class Map implements Entity {\n\n        private _canvas:HTMLCanvasElement\n        context:CanvasRenderingContext2D\n        screenPos:Iso.ScreenPosition = {x:0, y:0}\n\n        screenSize:Iso.Size\n        map:Iso.Size\n        tile:Iso.Size & { color:string }\n\n        mapPos:MapPosition\n\n        renderLayers:[ Array<Entity>, Array<Entity> ] = [  [], [] ]\n\n        gameLoopItnterval?:NodeJS.Timer\n\n        /**\n         * @desc constructor\n         * @param object $params - initial parameters\n         */\n        constructor(params:MapParameters) {\n\n            const canvas = document.getElementById(params.canvasId ?? 'canvas') as HTMLCanvasElement|null\n\n            if( canvas == null ) throw new Error(\"canvas is null!\")\n            const context = canvas.getContext('2d')\n            if( context == null ) throw new Error(\"2d context from canvas is null!\")\n            \n            this._canvas = canvas\n            this.context = context\n        \n            // canvas area details\n            this.screenSize = { \n                width: params.screen.width,\n                height: params.screen.height\n             };\n    \n            // size of isometric map\n            this.map = {\n                width: params.map.width,\n                height: params.map.height\n            };\n    \n            // size of single tile\n            this.tile = {\n                width: params.tile.width,\n                height: params.tile.height,\n                color: params.color ?? '#15B89A'\n            }\n    \n            // initial position of isometric map\n            this.mapPos = { x:this.screenSize.width / 2, y: this.tile.height }\n            \n        }\n    \n        /**\n         * \n         */\n        get canvas():HTMLCanvasElement {\n            return this._canvas\n        }\n\n        /**\n         * @desc draw isometric map\n         */\n        create() {\n            // set canvas size\n            this._canvas.setAttribute('width', `${this.screenSize.width}`);\n            this._canvas.setAttribute('height', `${this.screenSize.height}`);\n\n            // tiles drawing loops\n            for (let i = 0; i < this.map.width; i++) {\n                for ( let j = 0; j < this.map.height; j++) {\n                    // calculate coordinates\n                    const pos = {\n                        x: (i-j) * this.tile.width / 2 + this.mapPos.x,\n                        y: (i+j) * this.tile.height / 2 + this.mapPos.y\n                    }\n                    // draw single tile\n\n                    this._addTile( pos )\n                }\n            }\n            \n            this.gameLoopItnterval = setInterval( () => this.render(), 500 )\n        }\n    \n        render():void {\n\n            this.renderLayers[0].forEach( v =>  v.render() )\n            this.renderLayers[1].forEach( v =>  v.render() )\n\n        }\n        \n        /**\n         * @desc add a single tile to a layer\n         * @param int $x - position x on canvas area\n         * @param int $y - position y on canvas area\n         * @param layer \n         */\n        private _addTile = ( map:MapPosition, layer = 0):Tile => {\n            const result = new Tile( map, this )\n            this.renderLayers[layer].push( result )\n            return result\n        }\n\n        private _sortLayer = ( layer:number ) => \n            this.renderLayers[layer].sort( ($1,$2) => {\n                const dy = $1.screenPos.y - $2.screenPos.y \n                if( dy === 0 ) {\n                    return $2.screenPos.x - $1.screenPos.x\n                }\n                return dy\n            })\n        \n\n        /**\n         * add single prism to a layer\n         * @param x - position x on canvas area\n         * @param y - position y on canvas area\n         * @param layer \n         */\n        addPrism = ( screen:ScreenPosition, layer = 1 ):Prism|undefined =>  {\n\n            const map = this.convertScreenToIsometric(screen)\n\n            if( this.isOnMap(map) ) {\n                const result = new Prism( map, this, screen )\n                this.renderLayers[layer].push( result )\n                this._sortLayer(layer)\n                return result\n    \n            }\n        }\n\n        /**\n         * \n         * @param screen \n         * @returns \n         */\n        convertScreenToIsometric( screen:ScreenPosition ):Iso.MapPosition{\n            \n            const x = (screen.x - this.mapPos.x) / this.tile.width\n            const y = (screen.y - this.mapPos.y) / this.tile.height\n    \n           return { x: Math.floor(y + x) , y: Math.floor(y - x)  }\n        }\n\n        /**\n         * \n         * @param map \n         * @returns \n         */\n        convertIsometricToScreen = ( map:MapPosition ):Iso.ScreenPosition  => (\n            {\n                x: ( (map.x-map.y) * this.tile.width / 2 ) + this.mapPos.x,\n                y: ( (map.x+map.y) * this.tile.height / 2 ) + this.mapPos.y\n\n            })\n\n    \n        /**\n         * \n         * @param position \n         * @returns \n         */\n        isOnMap = (position:Iso.MapPosition):boolean  => \n                (position.x >= 0 && position.x < this.map.width \n                    && position.y >= 0 && position.y < this.map.height) \n        \n    \n    }\n\n}\n\n\n","import { Iso } from './isomap'\n\n\n/**\n * \n * @param event \n * @returns \n */\n    function getMousePosition(event:MouseEvent):Iso.MapPosition|null {\n    const canvas = event.target as HTMLCanvasElement|null;\n\n    if( canvas == null ) return null\n\n    const rect = canvas.getBoundingClientRect()\n\n    return {\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n    }\n}\n\n// isometric map settings\nconst params:Iso.MapParameters = {\n    screen: { width: 1024, height: 768 },\n    map: { width: 14, height: 14 },\n    tile: { width: 64, height: 32 }\n}\n\n// create map\nconst isoMap = new Iso.Map(params);\nisoMap.create();\n\nisoMap.canvas.addEventListener('mousedown', (event) => {\n        const mousePosition = getMousePosition(event)\n\n        if( mousePosition != null ) {\n            \n            isoMap.addPrism(mousePosition);\n        }\n\n}, false);\n\n\n\n"],"names":["Tile","mapPos","map","screenPos","x","y","render","context","tile","width","height","color","this","beginPath","moveTo","lineTo","stroke","fillStyle","fill","Prism","constructor","mapPos1","map1","screen1","convertIsometricToScreen","Map","params","renderLayers","_addTile","map2","layer","result","push","_sortLayer","sort","$1","$2","dy","addPrism","convertScreenToIsometric","isOnMap","position","canvas","document","getElementById","canvasId","Error","getContext","_canvas","screenSize","screen","create","setAttribute","i","j","pos","gameLoopItnterval","setInterval","forEach","v","Math","floor","$179e60c3a07e371a497299e469337a8f$export$23c566d4cbd4b94e","$a4018e003ec9cbe06ab0cc0137aa4e69$var$isoMap","addEventListener","event","mousePosition","target","rect","getBoundingClientRect","clientX","left","clientY","top","$a4018e003ec9cbe06ab0cc0137aa4e69$var$getMousePosition"],"version":3,"file":"index.f1137867.js.map"}