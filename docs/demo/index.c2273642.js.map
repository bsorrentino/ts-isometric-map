{"mappings":"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","sources":["src/ios.tile.ts","src/iso.prism.ts","src/iso.input.ts","src/index.ts","src/iso.ts","src/iso.utils.ts","src/iso.image.ts"],"sourcesContent":["import { Entity, MapPosition, ScreenPosition, TileMap } from './iso'\n\nexport class Tile implements Entity { \n\n    constructor( public screenPos:ScreenPosition, private mapPos:MapPosition, private map:TileMap) {}\n\n    render():void {\n        const  { x, y } = this.screenPos\n        const { context, tile: {width, height, color } } = this.map\n\n        // begin\n        context.beginPath()\n\n        // move to start point\n        context.moveTo(x - width / 2, y)\n\n        /**\n         * create four lines\n         * --------------------------------------------\n         *    step 1  |  step 2  |  step 3  |  step 4\n         * --------------------------------------------\n         *    /       |  /       |  /       |  /\\  \n         *            |  \\       |  \\/      |  \\/\n         * --------------------------------------------\n         */\n        context.lineTo(x - width, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x, y + height / 2)\n        context.lineTo(x - width / 2,  y)\n\n        // draw path\n        context.stroke()\n\n\n        // fill tile\n        context.fillStyle = color\n        context.fill() \n            \n        context.fillStyle = 'black'\n        context.fillText( `${this.mapPos.x},${this.mapPos.y}`, x - 40, y + 20 )\n\n    }\n}","import { Entity, ScreenPosition, TileMap } from './iso'\n\n/**\n * \n */\nexport class Prism implements Entity {\n\n    /**\n     * \n     * @param x - map x position\n     * @param y - map y position\n     * @param map \n     */\n    constructor( public screenPos:ScreenPosition, private map:TileMap) {\n        console.log( 'prism', screenPos )\n    }\n\n    render() {\n        const {x,y} = this.screenPos\n\n        const { context, tile: {width, height, color } } = this.map\n\n        // top\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y - height)\n        context.lineTo(x - width, y - height / 2)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x - width / 2,  y - height)\n\n        context.fillStyle = '#555555'\n        context.fill()\n\n        // left\n        context.beginPath()\n\n        context.moveTo(x - width, y - height / 2)\n        context.lineTo(x - width, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x - width, y - height / 2)\n\n        context.fillStyle = '#444444'\n        context.fill()\n\n        // right\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n\n        context.fillStyle = '#777777'\n        context.fill()            \n    }\n}\n","import { ScreenPosition } from \"./iso\";\n\nexport type KeyBoardValue = 'ArrowLeft'|'ArrowUp'|'ArrowRight'|'ArrowDown'\n\n\nclass Key {\n    isDown = false;\n    isUp = true;\n    press?:() => void\n    release?: () => void\n    unsubscribe:() => void\n\n    constructor( private value:KeyBoardValue, target:EventTarget ) {\n\n        const downHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isUp && this.press) this.press()\n              this.isDown = true\n              this.isUp = false\n              event.preventDefault()\n            }\n          }\n        \n        const upHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isDown && this.release) this.release()\n              this.isDown = false\n              this.isUp = true\n              event.preventDefault()\n            }\n          }\n        \n        target.addEventListener( 'keydown', downHandler as EventListener, false )\n        target.addEventListener( 'keyup', upHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'keydown', downHandler as EventListener, false )\n            target.removeEventListener( 'keyup', upHandler as EventListener, false )\n    \n        }\n    }\n\n\n  \n}\n\nclass Mouse {\n    isDown = false;\n    isUp = true;\n    press?:( event:MouseEvent ) => void\n    up?: ( event:MouseEvent ) => void\n    unsubscribe:() => void\n\n    constructor( target:Element ) {\n\n        const downHandler = (event:MouseEvent) => {\n            if (this.isUp && this.press) this.press(event)\n            this.isDown = true\n            this.isUp = false\n            event.preventDefault()\n        }\n        \n        const upHandler = (event:MouseEvent) => {\n            if (this.isDown && this.up) this.up(event)\n            this.isDown = false\n            this.isUp = true\n            event.preventDefault()\n          }\n        \n        target.addEventListener( 'mousedown', downHandler as EventListener, false )\n        target.addEventListener( 'mouseup', upHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'mousedown', downHandler as EventListener, false )\n            target.removeEventListener( 'mouseup', upHandler as EventListener, false )\n    \n        }\n\n        \n    }  \n}\n\nexport const keyboard = ( value:KeyBoardValue, target:EventTarget = document ) => (new Key(value, target))\nexport const mouse = ( target:Element ) => (new Mouse(target))\n\n/**\n* \n* @param event \n* @returns \n*/\nexport function getMousePositionRelativeToTarget(event:MouseEvent):ScreenPosition|null {\n   const elem = event.target as Element|null;\n\n   if( elem == null ) return null\n\n   const rect = elem.getBoundingClientRect()\n\n   return {\n       x: event.clientX - rect.left,\n       y: event.clientY - rect.top\n   }\n}\n","import { MapParameters, TileMap, ScreenPosition } from './iso'\nimport { Prism } from './iso.prism'\nimport { Image as ImageEntity } from './iso.image'\nimport { keyboard, mouse, getMousePositionRelativeToTarget } from './iso.input' \n\n// isometric map settings\nconst params:MapParameters = {\n    screen: { width: 1024, height: 768 },\n    mapSize: { width: 14, height: 14 },\n    tileSize: { width: 64, height: 32 }\n}\n\n// create map\nconst isoMap = new TileMap(params);\nisoMap.create();\nisoMap.loadImages( '/assets/man-ne.png', '/assets/man-nw.png', '/assets/man-se.png',' /assets/man-sw.png' )\n\n\nlet left = keyboard(\"ArrowLeft\"),\n      up = keyboard(\"ArrowUp\"),\n      right = keyboard(\"ArrowRight\"),\n      down = keyboard(\"ArrowDown\");\n\nconst _mouse = mouse(isoMap.canvas)\n\n_mouse.press =  (event) => {\n        let pos = getMousePositionRelativeToTarget(event)\n\n        if( pos != null ) {\n            pos = isoMap.convertScreenToIso(pos) // adjust position on map\n                \n            isoMap.addEntity( new Prism( isoMap.convertIsoToScreen( pos ), isoMap) )\n \n        }\n}\n\nconst img = new ImageEntity('man-ne', isoMap.convertIsoToScreen( {x:0, y:0} ), isoMap )\n\nconst success = isoMap.addEntity( img )\n\nconsole.log( 'add image ', success )\n\nleft.press = () => {\n\n    console.log( 'left press' )\n}\n\nright.press = () => {\n\n    console.log( 'right press' )\n}\n\nup.press = () => {\n\n    console.log( 'up press' )\n}\n\ndown.press = () => {\n\n    console.log( 'down press' )\n}","\nimport { basename } from './iso.utils'\nimport { Tile } from './ios.tile'\n\nexport type MapPosition = {\n    x:number\n    y:number\n}\n\nexport type ScreenPosition = {\n    x:number\n    y:number\n}\n\nexport type Size = {\n    width:number\n    height:number\n}\n\nexport type MapParameters = {\n    screen:Size\n    mapSize:Size\n    tileSize:Size\n    canvasId?:string\n    color?:string\n}\n\nexport interface Entity {\n    \n    screenPos:ScreenPosition\n\n    render():void\n}\n\n\n\n\n\n\nexport class TileMap implements Entity {\n\n    private _canvas:HTMLCanvasElement\n    context:CanvasRenderingContext2D\n    screenPos:ScreenPosition = {x:0, y:0}\n\n    screenSize:Size\n    mapSize:Size\n    tile:Size & { color:string }\n\n    mapPos:MapPosition\n\n    renderLayers:[ Array<Entity>, Array<Entity> ] = [  [], [] ]\n\n    gameLoopItnterval?:NodeJS.Timer\n\n    images = new Map<string,HTMLImageElement>()\n\n    /**\n     * @desc constructor\n     * @param object $params - initial parameters\n     */\n    constructor(params:MapParameters) {\n\n        const canvas = document.getElementById(params.canvasId ?? 'canvas') as HTMLCanvasElement|null\n\n        if( canvas == null ) throw new Error(\"canvas is null!\")\n        const context = canvas.getContext('2d')\n        if( context == null ) throw new Error(\"2d context from canvas is null!\")\n        \n        this._canvas = canvas\n        this.context = context\n    \n        // canvas area details\n        this.screenSize = { \n            width: params.screen.width,\n            height: params.screen.height\n            };\n\n        // size of isometric map\n        this.mapSize = {\n            width: params.mapSize.width,\n            height: params.mapSize.height\n        };\n\n        // size of single tile\n        this.tile = {\n            width: params.tileSize.width,\n            height: params.tileSize.height,\n            color: params.color ?? '#15B89A'\n        }\n\n        // initial position of isometric map\n        this.mapPos = { x:this.screenSize.width / 2, y: this.tile.height }\n        \n    }\n\n    /**\n     * \n     */\n    get canvas():HTMLCanvasElement {\n        return this._canvas\n    }\n\n    /**\n     * \n     * @returns \n     */\n    clear = () => this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    \n\n    /**\n     * @desc draw isometric map\n     */\n    create() {\n        // set canvas size\n        this._canvas.setAttribute('width', `${this.screenSize.width}`);\n        this._canvas.setAttribute('height', `${this.screenSize.height}`);\n\n        // tiles drawing loops\n        for (let x = 0; x < this.mapSize.width; x++) {\n            for ( let y = 0; y < this.mapSize.height; y++) {\n                this._addTile( {x:x, y:y } )\n            }\n        }\n        \n        this.gameLoopItnterval = setInterval( () => this.render(), 500 )\n    }\n\n    render():void {\n\n        this.renderLayers[0].forEach( v =>  v.render() )\n        this.renderLayers[1].forEach( v =>  v.render() )\n\n    }\n    \n    /**\n     * @desc add a single tile to a layer\n     * @param int $x - position x on canvas area\n     * @param int $y - position y on canvas area\n     * @param layer \n     */\n    private _addTile = ( map:MapPosition, layer = 0):Tile => {\n        const screen = this.convertIsoToScreen( map) \n        const result = new Tile( screen, map, this )\n        this.renderLayers[layer].push( result )\n        return result\n    }\n\n    /**\n     * \n     * @param layer \n     * @returns \n     */\n    private _sortLayer = ( layer:number ) => \n        this.renderLayers[layer].sort( ($1,$2) => {\n            const dy = $1.screenPos.y - $2.screenPos.y \n            if( dy === 0 ) {\n                return $2.screenPos.x - $1.screenPos.x\n            }\n            return dy\n        })\n    \n\n    /**\n     * add single prism to a layer\n     * @param x - position x on canvas area\n     * @param y - position y on canvas area\n     * @param layer \n     */\n    addEntity = <T extends Entity>( entity:T, layer = 1 ):boolean =>  {\n\n        const map = this.convertScreenToIso(entity.screenPos)\n\n        if( this.isOnMap(map) ) {\n            this.renderLayers[layer].push( entity )\n            this._sortLayer(layer)\n            return true\n\n        }\n\n        return false\n    }\n\n    /**\n     * \n     * @param screen \n     * @returns \n     */\n    convertScreenToIso( screen:ScreenPosition ):MapPosition{\n        \n        const x = (screen.x - this.mapPos.x) / this.tile.width\n        const y = (screen.y - this.mapPos.y) / this.tile.height\n\n        return { x: Math.floor(y + x) , y: Math.floor(y - x)  }\n    }\n\n    /**\n     * \n     * @param map \n     * @returns \n     */\n    convertIsoToScreen = ( map:MapPosition ):ScreenPosition  => (\n        {\n            x: ( (map.x-map.y) * this.tile.width / 2 ) + this.mapPos.x,\n            y: ( (map.x+map.y) * this.tile.height / 2 ) + this.mapPos.y\n\n        })\n\n\n    /**\n     * \n     * @param position \n     * @returns \n     */\n    isOnMap = (position:MapPosition):boolean  => \n            (position.x >= 0 && position.x < this.mapSize.width \n                && position.y >= 0 && position.y < this.mapSize.height) \n\n\n    /**\n     * \n     * @param path \n     * @returns \n     */\n    loadImages( ...paths: string[] )  {\n\n        paths.forEach( path => {\n            const name = basename(path)\n            \n            if( name ) {\n                let result = new Image()\n                result.src = path\n                result.onload = ( event:any ) => {\n                    console.log( `image ${name} from path: ${path} loaded`, event )\n                }\n                this.images.set( name, result)\n            }\n            else {\n                console.warn( `image path: ${path} is not valid!` )\n                // throw Error( `image path: ${path} is not valid!`)\n            }\n\n        })\n    }\n}\n\n\n\n","/**\n * \n * @param path \n * @returns \n */\nexport const basename = ( path:string ):string|undefined => {\n    const elem = path.split(\"/\")\n    if( elem.length > 0 ) {\n        const last = elem[ elem.length - 1]\n        const result = /(.+)[.](.+)$/.exec(last)    \n        if( result != null ) {\n            return result[1]\n        }\n    }\n} \n    \n","\nimport { Entity, ScreenPosition, TileMap } from './iso'\n\nexport class Image implements Entity {\n    source?:HTMLImageElement\n\n    constructor(  private basename:string, public screenPos:ScreenPosition, private map:TileMap) {\n        console.log( 'image', screenPos )\n\n        this.source =  map.images.get( basename )\n    }\n\n    render():void {\n        if( this.source ) {\n            const { x, y } = this.screenPos\n            this.map.context.drawImage( this.source, x, y  )    \n        }\n        else {\n            this.source =  this.map.images.get( this.basename )\n        }\n    }\n}"],"names":["$2dd197c442f1bed314dd424b0db8422e$export$4cbd7057afcc19d","screenPos","mapPos","map","render","x","y","this","context","tile","width","height","color","beginPath","moveTo","lineTo","stroke","fillStyle","fill","fillText","$718fbb905372c26711d5aae570ddea86$export$c6ec6fa8b613b252","constructor","console","log","$f7a0ca685fc15ff0733c8744dc854746$var$Key","value","target","isDown","isUp","downHandler","event","key","press","preventDefault","upHandler","release","addEventListener","unsubscribe","removeEventListener","$f7a0ca685fc15ff0733c8744dc854746$var$Mouse","target1","downHandler1","upHandler1","up","$f7a0ca685fc15ff0733c8744dc854746$export$ea6328a15d7d48c9","value1","target2","document","$a4018e003ec9cbe06ab0cc0137aa4e69$var$isoMap","params","renderLayers","images","Map","clear","clearRect","canvas","_addTile","layer","screen","convertIsoToScreen","result","push","_sortLayer","sort","$1","$2","dy","addEntity","entity","convertScreenToIso","isOnMap","position","mapSize","getElementById","canvasId","Error","getContext","_canvas","screenSize","tileSize","create","setAttribute","gameLoopItnterval","setInterval","forEach","v","Math","floor","loadImages","paths","path","name","elem","split","length","last","exec","$04b7f286a5ed5d84632c73262f84779c$export$6aeba2462e8c6a4","Image","src","onload","set","warn","$a4018e003ec9cbe06ab0cc0137aa4e69$var$left","$a4018e003ec9cbe06ab0cc0137aa4e69$var$up","$a4018e003ec9cbe06ab0cc0137aa4e69$var$right","$a4018e003ec9cbe06ab0cc0137aa4e69$var$down","pos","rect","getBoundingClientRect","clientX","left","clientY","top","$f7a0ca685fc15ff0733c8744dc854746$export$13e93795cd93500c","$a4018e003ec9cbe06ab0cc0137aa4e69$var$img","basename","source","get","drawImage","$a4018e003ec9cbe06ab0cc0137aa4e69$var$success"],"version":3,"file":"index.c2273642.js.map"}