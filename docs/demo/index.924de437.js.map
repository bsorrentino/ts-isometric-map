{"mappings":"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","sources":["src/iso.tile.ts","src/iso.ts","src/iso.prism.ts","src/iso.input.ts","src/index.ts","src/iso.utils.ts","src/iso.person.ts"],"sourcesContent":["import { Entity, MapPosition, ScreenPosition, TileMap } from './iso'\n\nexport class Tile implements Entity { \n\n    highlight = false\n\n    constructor( public screenPos:ScreenPosition, public mapPos:MapPosition, private map:TileMap) {\n    }\n\n    compare( e:Tile ):number {\n        return ( e.highlight ) ? -1 : 0\n    }\n\n    render():void {\n\n        const v = this.map.getTileVertex(this.screenPos)\n        \n        const { context, tile: { color } } = this.map\n\n        context.save()\n\n        /**\n         * create four lines\n         * --------------------------------------------\n         *    step 1  |  step 2  |  step 3  |  step 4\n         * --------------------------------------------\n         *    /       |  /       |  /       |  /\\  \n         *            |  \\       |  \\/      |  \\/\n         * --------------------------------------------\n         */\n\n        // begin\n        context.beginPath()\n        // move to start point\n        context.moveTo(v.top.x, v.top.y)\n        // define lines\n        context.lineTo(v.left.x, v.left.y)\n        context.lineTo(v.bottom.x, v.bottom.y)\n        context.lineTo(v.right.x, v.right.y)\n        context.lineTo(v.top.x, v.top.y)        \n        context.strokeStyle = 'black'\n\n        // draw path\n        context.stroke()\n    \n\n        // fill tile\n        context.fillStyle = (this.highlight) ? '#ffff00' : color\n        context.fill() \n    \n        // Debug\n        if( this.highlight ) {\n            this._drawTileRect()\n            this._drawMapPos()\n        }\n\n        context.restore()\n    }\n\n    private _drawMapPos() {\n\n        const { context } = this.map\n        const { x, y } = this.screenPos // topRight\n\n        context.fillStyle = 'black'\n        context.fillText( `${this.mapPos.x},${this.mapPos.y}`, x - 40, y + 20 )\n\n    }\n    private _drawTileRect( ) {\n\n        // Debug\n        const { context, tile: { width, height } } = this.map\n        const { topLeft: { x, y } } = this.map.getTileRect(this.screenPos)\n        context.beginPath()\n        context.rect( x, y, width, height)\n        context.stroke()\n\n    }\n}","\nimport { basename } from './iso.utils'\nimport { Tile } from './iso.tile'\n\n\nexport enum Direction {\n    NW, NE, SW, SE\n}\nexport type Position = {\n    x:number\n    y:number\n}\n\nexport type MapPosition = Position\nexport type ScreenPosition = Position\n\nexport type TileVertex = {\n    top:Position\n    left:Position\n    right:Position\n    bottom:Position\n}\n\nexport type TileRect = {\n    topRight:Position\n    topLeft:Position\n    bottomRight:Position\n    bottomLeft:Position\n}\n\nexport type Size = {\n    width:number\n    height:number\n}\n\nexport type MapParameters = {\n    screen:Size\n    mapSize:Size\n    tileSize:Size\n    canvasId?:string\n    color?:string\n}\n\nexport interface Entity {\n    \n    screenPos:ScreenPosition\n\n    render():void\n\n    compare( e:Entity ):number\n}\n\n/**\n * \n */\nexport abstract class BaseEntity implements Entity {\n\n    constructor( public screenPos:Position ) {}\n\n    abstract render(): void \n\n    compare(e: Entity): number {\n        const dy = this.screenPos.y - e.screenPos.y \n        if( dy === 0 ) {\n            return this.screenPos.x - e.screenPos.x\n        }\n        return dy\n    }\n\n}\n\n/**\n * \n */\nexport class TileMap implements Entity {\n\n    private _canvas:HTMLCanvasElement\n    context:CanvasRenderingContext2D\n    screenPos:ScreenPosition = {x:0, y:0}\n\n    screenSize:Size\n    mapSize:Size\n    tile:Size & { color:string }\n\n    mapPos:MapPosition\n\n    renderLayers:[ Array<Entity>, Array<Entity>, Array<Entity> ] = [  [], [], [] ]\n\n    gameLoopItnterval?:NodeJS.Timer\n\n    images = new Map<string,HTMLImageElement>()\n\n    /**\n     * @desc constructor\n     * @param object $params - initial parameters\n     */\n    constructor(params:MapParameters) {\n\n        const canvas = document.getElementById(params.canvasId ?? 'canvas') as HTMLCanvasElement|null\n\n        if( canvas == null ) throw new Error(\"canvas is null!\")\n        const context = canvas.getContext('2d')\n        if( context == null ) throw new Error(\"2d context from canvas is null!\")\n        \n        this._canvas = canvas\n        this.context = context\n    \n        // canvas area details\n        this.screenSize = { \n            width: params.screen.width,\n            height: params.screen.height\n            };\n\n        // size of isometric map\n        this.mapSize = {\n            width: params.mapSize.width,\n            height: params.mapSize.height\n        };\n\n        // size of single tile\n        this.tile = {\n            width: params.tileSize.width,\n            height: params.tileSize.height,\n            color: params.color ?? '#15B89A'\n        }\n\n        // initial position of isometric map\n        this.mapPos = { x:this.screenSize.width / 2, y: this.tile.height * 2 }\n    }\n\n    compare( e:TileMap ):number {\n        return 0\n    }\n\n    /**\n     * \n     */\n    get canvas():HTMLCanvasElement {\n        return this._canvas\n    }\n\n    /**\n     * \n     * @returns \n     */\n    clear = () => this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    \n\n    /**\n     * @desc draw isometric map\n     */\n    create() {\n        // set canvas size\n        this._canvas.setAttribute('width', `${this.screenSize.width}`);\n        this._canvas.setAttribute('height', `${this.screenSize.height}`);\n\n        // tiles drawing loops\n        for (let x = 0; x < this.mapSize.width; x++) {\n            for ( let y = 0; y < this.mapSize.height; y++) {\n                this._addTile( {x:x, y:y } )\n            }\n        }\n        \n        this.gameLoopItnterval = setInterval( () => this.render(), 1000/30 )\n    }\n\n    /**\n     * \n     */\n    render():void {\n        this.clear()\n\n        this.renderLayers[0]\n            .sort( ($1,$2) => $1.compare($2) )\n            .forEach( v =>  v.render() )\n\n        this.renderLayers[1]\n            .concat( this.renderLayers[2])\n            .sort( ($1,$2) => $1.compare($2) )\n            .forEach( v =>  v.render() )\n\n    }\n    \n    /**\n     * @desc add a single tile to a layer\n     * @param int $x - position x on canvas area\n     * @param int $y - position y on canvas area\n     * @param layer \n     */\n    private _addTile = ( map:MapPosition, layer = 0):Tile => {\n        const screen = this.convertIsoToScreen( map) \n        const result = new Tile( screen, map, this )\n        this.renderLayers[layer].push( result )\n        return result\n    }\n\n    /**\n     * \n     * @param layer \n     * @param predicate \n     * @returns \n     */\n    private  _findEntity<T extends Entity>( layer:number, predicate:( entity:Entity, index:number ) => boolean ):T|undefined {\n        return this.renderLayers[layer].find( predicate ) as T\n    }\n\n    /**\n     * \n     * @param screenPos \n     */\n    findTileByScreenPos( screenPos:ScreenPosition ) {\n        return this._findEntity<Tile>( 0, ( e, i ) => {\n\n            const isoPos = this.convertScreenToIso(screenPos)\n            const { mapPos } = e as Tile\n\n            return mapPos.x === isoPos.x && mapPos.y === isoPos.y \n\n        })\n    }\n\n    /**\n     * \n     * @param screenPos \n     */\n     findTileByIsoPos( isoPos:MapPosition ) {\n        return this._findEntity<Tile>( 0, ( e, i ) => {\n\n            const { mapPos } = e as Tile\n\n            return mapPos.x === isoPos.x && mapPos.y === isoPos.y \n\n        })\n    }\n\n    /**\n     * add single prism to a layer\n     * @param x - position x on canvas area\n     * @param y - position y on canvas area\n     * @param layer \n     */\n    addEntity = <T extends Entity>( entity:T, layer = 1 ):boolean =>  {\n\n        const map = this.convertScreenToIso(entity.screenPos)\n\n        if( this.isOnMap(map) ) {\n            this.renderLayers[layer].push( entity )\n            return true\n\n        }\n\n        return false\n    }\n\n    /**\n     * \n     * @param screen \n     * @returns \n     */\n    convertScreenToIso( screen:ScreenPosition ):MapPosition {\n        \n        const x = (screen.x - this.mapPos.x) / this.tile.width\n        const y = (screen.y - this.mapPos.y) / this.tile.height\n\n        return { \n            x: Math.floor(y + x), \n            y: Math.floor(y - x)  \n        }\n    }\n\n    /**\n     * \n     * @param map \n     * @returns \n     */\n    convertIsoToScreen = ( map:MapPosition ):ScreenPosition  => ({\n            x: ( (map.x-map.y) * this.tile.width / 2 ) + this.mapPos.x,\n            y: ( (map.x+map.y) * this.tile.height / 2 ) + this.mapPos.y\n        })\n\n    /**\n     * \n     * @param pos \n     * @returns \n     */\n     getTileVertex = (pos:ScreenPosition):TileVertex => ({\n        top:    { x: pos.x - this.tile.width / 2, y: pos.y  },\n        left:   { x: pos.x - this.tile.width, y: pos.y + this.tile.height / 2 },\n        right:  { x: pos.x, y: pos.y + this.tile.height / 2 },\n        bottom: { x: pos.x - this.tile.width / 2, y: pos.y + this.tile.height }\n    })\n\n    /**\n     * \n     * @param pos \n     * @returns \n     */\n    getTileRect = (pos:ScreenPosition):TileRect => ({\n            topRight:       pos,\n            bottomLeft:     { x: pos.x - this.tile.width, y: pos.y + this.tile.height },\n            bottomRight:    { x:pos.x, y: pos.y + this.tile.height },\n            topLeft:        { x: pos.x - this.tile.width, y: pos.y }\n        })\n\n    /**\n     * \n     * @param position \n     * @returns \n     */\n    isOnMap = (position:MapPosition):boolean  => \n            (position.x >= 0 && position.x < this.mapSize.width \n                && position.y >= 0 && position.y < this.mapSize.height) \n\n\n    /**\n     * \n     * @param path \n     * @returns \n     */\n    loadImages( ...paths: string[] )  {\n\n        paths.forEach( path => {\n            const name = basename(path)\n            \n            if( name ) {\n                let result = new Image()\n                result.src = path\n                result.onload = ( event:any ) => {\n                    console.log( `image ${name} from path: ${path} loaded`, event )\n                }\n                this.images.set( name, result)\n            }\n            else {\n                console.warn( `image path: ${path} is not valid!` )\n                // throw Error( `image path: ${path} is not valid!`)\n            }\n\n        })\n    }\n\n    /**\n     * \n     * @param basename \n     * @param screenPos \n     */\n    renderImage( basename:string, screenPos:ScreenPosition ):void {\n        const source = this.images.get( basename )\n\n        if( source ) {\n            const { bottomLeft: {x, y} } = this.getTileRect(screenPos)\n            this.context.drawImage( source, x, y - source!.naturalHeight )    \n        }\n    }\n\n    checkCollision( screenPos:ScreenPosition, dir:Direction, layer = 1, filter?:(e:Entity) => boolean):boolean {\n\n        const entities = (filter) ? \n                        this.renderLayers[layer].filter( filter ) : \n                        this.renderLayers[layer]\n\n        const vt = this.getTileVertex(screenPos)\n\n        let predicate:((e:Entity) => boolean)|undefined\n\n        // console.log( 'collision', dir )\n        switch( dir ) {\n        case Direction.SW:\n        case Direction.SE:\n            predicate = ( e ) => {\n                const { top, left } = this.getTileVertex(e.screenPos)\n                const { x,y } = vt.left\n\n                // console.log( vt.left, 'top', top, 'left', left )\n                return ( x < top.x && x >= left.x ) &&\n                       ( y > top.y && y <= left.y)\n            }\n            break\n        case Direction.NW:\n        case Direction.NE:\n            predicate = ( e ) => {\n                const { bottom, right } = this.getTileVertex(e.screenPos)\n                const { x,y } = vt.right\n\n                // console.log( vt.right, 'bottom', bottom, 'right', right )\n                return ( x > bottom.x && x <= right.x ) &&\n                       ( y < bottom.y && y >= right.y)\n            }\n            break\n        }\n\n        return ( predicate ) ?\n            entities.find( predicate )!==undefined : false\n    }\n\n}\n\n\n\n","import { BaseEntity, Entity, ScreenPosition, TileMap } from './iso'\n\n/**\n * \n */\nexport class Prism extends BaseEntity {\n\n    /**\n     * \n     * @param x - map x position\n     * @param y - map y position\n     * @param map \n     */\n    constructor( screenPos:ScreenPosition, private map:TileMap) {\n        super( screenPos )\n    }\n\n    compare( e:Prism ):number {\n        \n        const dy = this.screenPos.y - e.screenPos.y \n        if( dy === 0 ) {\n            return this.screenPos.x - e.screenPos.x\n        }\n        return dy\n    }\n\n    render() {\n        const {x,y} = this.screenPos\n\n        const { context, tile: {width, height } } = this.map\n\n        // top\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y - height)\n        context.lineTo(x - width, y - height / 2)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x - width / 2,  y - height)\n\n        context.fillStyle = '#555555'\n        context.fill()\n\n        // left\n        context.beginPath()\n\n        context.moveTo(x - width, y - height / 2)\n        context.lineTo(x - width, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n        context.lineTo(x - width, y - height / 2)\n\n        context.fillStyle = '#444444'\n        context.fill()\n\n        // right\n        context.beginPath()\n\n        context.moveTo(x - width / 2, y)\n        context.lineTo(x, y - height / 2)\n        context.lineTo(x, y + height / 2)\n        context.lineTo(x - width / 2, y + height)\n        context.lineTo(x - width / 2, y)\n\n        context.fillStyle = '#777777'\n        context.fill()            \n    }\n}\n","import { ScreenPosition } from \"./iso\";\n\nexport type KeyBoardValue = 'ArrowLeft'|'ArrowUp'|'ArrowRight'|'ArrowDown'\n\n\nclass Key {\n    isDown = false;\n    isUp = true;\n    press?:() => void\n    release?: () => void\n    unsubscribe:() => void\n\n    constructor( private value:KeyBoardValue, target:EventTarget ) {\n\n        const downHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isUp && this.press) this.press()\n              this.isDown = true\n              this.isUp = false\n              event.preventDefault()\n            }\n          }\n        \n        const upHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isDown && this.release) this.release()\n              this.isDown = false\n              this.isUp = true\n              event.preventDefault()\n            }\n          }\n        \n        target.addEventListener( 'keydown', downHandler as EventListener, false )\n        target.addEventListener( 'keyup', upHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'keydown', downHandler as EventListener, false )\n            target.removeEventListener( 'keyup', upHandler as EventListener, false )\n    \n        }\n    }\n\n\n  \n}\n\nexport class Mouse {\n    press?:( event:MouseEvent ) => void\n    up?: ( event:MouseEvent ) => void\n    move?: ( event:MouseEvent ) => void\n\n    unsubscribe:() => void\n\n    constructor( target:Element ) {\n\n        const downHandler = (event:MouseEvent) => {\n            if (this.press) this.press(event)\n            event.preventDefault()\n        }\n        \n        const upHandler = (event:MouseEvent) => {\n            if (this.up) this.up(event)\n            event.preventDefault()\n        }\n\n        const moveHandler = (event:MouseEvent) => {\n          if (this.move) this.move(event)\n          event.preventDefault()\n        }\n        \n        target.addEventListener( 'mousedown', downHandler as EventListener, false )\n        target.addEventListener( 'mouseup', upHandler as EventListener, false )\n        target.addEventListener( 'mousemove', moveHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'mousedown', downHandler as EventListener, false )\n            target.removeEventListener( 'mouseup', upHandler as EventListener, false )\n            target.removeEventListener( 'mousemove', moveHandler as EventListener, false )\n        }\n\n        \n    }  \n\n    /**\n    * \n    * @param event \n    * @returns \n    */\n    getMousePosition(event:MouseEvent):ScreenPosition|null {\n      const elem = event.target as Element|null;\n\n      if( elem == null ) return null\n\n      const rect = elem.getBoundingClientRect()\n\n      return {\n          x: event.clientX - rect.left,\n          y: event.clientY - rect.top\n      }\n  }\n\n}\n\nexport const keyboard = ( value:KeyBoardValue, target:EventTarget = document ) => (new Key(value, target))\nexport const mouse = ( target:Element ) => (new Mouse(target))\n","import { Direction, MapParameters, TileMap } from './iso'\nimport { Tile } from './iso.tile'\nimport { Prism } from './iso.prism'\nimport { Person } from './iso.person'\nimport { keyboard, mouse } from './iso.input' \n\n// isometric map settings\nconst params:MapParameters = {\n    screen: { width: 1024, height: 800 },\n    mapSize: { width: 14, height: 14 },\n    tileSize: { width: 64, height: 32 }\n}\n\nconst outDiv = document.getElementById('debug')\n\n// create map\nconst isoMap = new TileMap(params);\nisoMap.create();\nisoMap.loadImages( 'assets/man-ne.png', 'assets/man-nw.png', 'assets/man-se.png',' assets/man-sw.png' )\n\nlet left = keyboard(\"ArrowLeft\"),\n      up = keyboard(\"ArrowUp\"),\n      right = keyboard(\"ArrowRight\"),\n      down = keyboard(\"ArrowDown\");\n\n// const _mouse = mouse( isoMap.canvas )\nconst _mouse = mouse( document.body )\n\n_mouse.press =  (event) => {\n        let pos = _mouse.getMousePosition(event)\n\n        if( pos != null ) {\n\n            pos = isoMap.convertScreenToIso(pos) // adjust position on map\n                \n            isoMap.addEntity( new Prism( isoMap.convertIsoToScreen( pos ), isoMap) )\n        }\n}\n\nlet lastTile:Tile|undefined\n\n_mouse.move = (event) => {\n    const mousepos = _mouse.getMousePosition(event)\n\n    if( mousepos != null ) {\n\n        const pos = isoMap.convertScreenToIso(mousepos) // adjust position on map\n    \n        outDiv!.innerHTML = `[${mousepos.x},${mousepos.y}] - [${pos.x},${pos.y}]`\n        const tile = isoMap.findTileByIsoPos(pos)\n\n        if( tile ) {\n            if( lastTile ) {\n                lastTile.highlight = false\n            }\n            //console.log( `${tile.mapPos.x},${tile.mapPos.y}`)\n            lastTile = tile \n            lastTile.highlight = true\n        }\n    }\n}\n\n// const img = new ImageEntity('man-ne', isoMap.convertIsoToScreen( {x:1, y:0} ), isoMap )\n// isoMap.addEntity( img )\n\nconst person = new Person(  {x:1, y:1}, isoMap )\n\nisoMap.addEntity( person, 2 )\n\nconst release = () => person.move = null\n\nleft.press = () => person.move = Direction.SW \nright.press = () => person.move = Direction.NE\nup.press = () => person.move = Direction.NW\ndown.press = () => person.move = Direction.SE\n\nleft.release = release\nright.release = release\ndown.release = release\nup.release = release\n\n","/**\n * \n * @param path \n * @returns \n */\nexport const basename = ( path:string ):string|undefined => {\n    const elem = path.split(\"/\")\n    if( elem.length > 0 ) {\n        const last = elem[ elem.length - 1]\n        const result = /(.+)[.](.+)$/.exec(last)    \n        if( result != null ) {\n            return result[1]\n        }\n    }\n} \n    \n","import { Entity, ScreenPosition, MapPosition, TileMap, BaseEntity, Direction } from './iso'\n\ntype ImageSet = 'man-se'|'man-sw'|'man-ne'|'man-nw'\n\nexport class Person extends BaseEntity {\n\n    move:Direction|null = null\n    currentImage:ImageSet = 'man-se'\n\n    constructor( public mapPos:MapPosition, private map:TileMap) {\n        super( map.convertIsoToScreen( mapPos ) )\n    }\n\n    compare( e:Person ):number {\n        \n        const dy = this.screenPos.y - e.screenPos.y \n        if( dy === 0 ) {\n            return this.screenPos.x - e.screenPos.x\n        }\n        return dy\n    }\n\n    private _moveTo( dir:Direction, _mapPos:MapPosition, image:ImageSet) {\n        if( this.map.isOnMap( _mapPos ) ){\n            this.currentImage = image\n\n            const _screenPos = this.map.convertIsoToScreen( _mapPos )\n\n            if( !this.map.checkCollision( _screenPos, dir ) ) {\n                this.mapPos     = _mapPos\n                this.screenPos  = _screenPos\n            }\n        }\n\n    }\n\n    render():void {\n\n        switch( this.move ) {\n            case Direction.SE:\n                this._moveTo( Direction.SE, { x:this.mapPos.x + 1, y:this.mapPos.y }, 'man-se')\n                break\n            case Direction.SW:\n                this._moveTo( Direction.SW, { x:this.mapPos.x,y:this.mapPos.y+1}, 'man-sw')\n                break\n            case Direction.NE:\n                this._moveTo( Direction.NE, { x:this.mapPos.x,y:this.mapPos.y-1 }, 'man-ne')\n                break\n            case Direction.NW:\n                this._moveTo( Direction.NW, { x:this.mapPos.x-1,y:this.mapPos.y }, 'man-nw')\n                break\n\n        }\n        this.map.renderImage(this.currentImage, this.screenPos )\n        \n    }\n}"],"names":["$8c16fa1d59734288940dd6104ed4bcc0$export$4cbd7057afcc19d","screenPos","mapPos","map","highlight","compare","e","render","v","this","getTileVertex","context","tile","color","save","beginPath","moveTo","top","x","y","lineTo","left","bottom","right","strokeStyle","stroke","fillStyle","fill","_drawTileRect","_drawMapPos","restore","fillText","width","height","topLeft","getTileRect","rect","Direction","$4a34614f6163d09f68bba6ca66a67f19$export$96381b1a7f788138","$4a34614f6163d09f68bba6ca66a67f19$export$a4604b21441a2505","screenPos1","dy","$718fbb905372c26711d5aae570ddea86$export$c6ec6fa8b613b252","constructor","super","$f7a0ca685fc15ff0733c8744dc854746$var$Key","value","target","isDown","isUp","downHandler","event","key","press","preventDefault","upHandler","release","addEventListener","unsubscribe","removeEventListener","$f7a0ca685fc15ff0733c8744dc854746$export$1e7d889471c16c64","target1","downHandler1","upHandler1","up","moveHandler","move","getMousePosition","elem","getBoundingClientRect","clientX","clientY","$f7a0ca685fc15ff0733c8744dc854746$export$ea6328a15d7d48c9","value1","target2","document","$a4018e003ec9cbe06ab0cc0137aa4e69$var$outDiv","getElementById","$a4018e003ec9cbe06ab0cc0137aa4e69$var$isoMap","params","renderLayers","images","Map","clear","clearRect","canvas","_addTile","layer","screen","convertIsoToScreen","result","push","addEntity","entity","convertScreenToIso","isOnMap","pos","topRight","bottomLeft","bottomRight","position","mapSize","canvasId","Error","getContext","_canvas","screenSize","tileSize","create","setAttribute","gameLoopItnterval","setInterval","sort","$1","$2","forEach","concat","_findEntity","predicate","find","findTileByScreenPos","i","isoPos","findTileByIsoPos","Math","floor","loadImages","paths","path","name","split","length","last","exec","$04b7f286a5ed5d84632c73262f84779c$export$6aeba2462e8c6a4","Image","src","onload","console","log","set","warn","renderImage","basename","source","get","drawImage","naturalHeight","checkCollision","dir","filter","entities","vt","SW","SE","NW","NE","undefined","$a4018e003ec9cbe06ab0cc0137aa4e69$var$left","$a4018e003ec9cbe06ab0cc0137aa4e69$var$up","$a4018e003ec9cbe06ab0cc0137aa4e69$var$right","$a4018e003ec9cbe06ab0cc0137aa4e69$var$down","$a4018e003ec9cbe06ab0cc0137aa4e69$var$_mouse","body","$a4018e003ec9cbe06ab0cc0137aa4e69$var$lastTile","mousepos","innerHTML","$a4018e003ec9cbe06ab0cc0137aa4e69$var$person","currentImage","_moveTo","_mapPos","image","_screenPos","$a4018e003ec9cbe06ab0cc0137aa4e69$var$release"],"version":3,"file":"index.924de437.js.map"}