{"mappings":"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","sources":["src/iso.tile.ts","src/iso.ts","src/iso.person.ts","src/iso.input.ts","src/iso.image.ts","src/index.ts","src/iso.utils.ts"],"sourcesContent":["import { Entity, MapPosition, ScreenPosition, TileMap } from './iso'\n\nexport class Tile implements Entity { \n\n    highlight = false\n\n    constructor( public screenPos:ScreenPosition, public mapPos:MapPosition, private map:TileMap) {\n    }\n\n    compare( e:Tile ):number {\n        return ( e.highlight ) ? -1 : 0\n    }\n\n    render():void {\n        const { context } = this.map\n\n        context.save()\n\n        this._renderLines()\n\n        // if( this.highlight ) {\n        //     this._renderLines()\n        // }\n        // else  {\n        //     this._renderImage()\n        // }\n\n        // Debug\n        if( this.highlight ) {\n            this._drawTileRect()\n            this._drawMapPos()\n        }\n\n        context.restore()\n    }\n\n    private _renderImage():void {\n        this.map.renderImageScaled('cretebrick970', this.screenPos, this.map.tile )\n    }\n\n    private _renderLines():void {\n\n        const v = this.map.getTileVertex(this.screenPos)\n        \n        const { context, tile: { color } } = this.map\n\n        /**\n         * create four lines\n         * --------------------------------------------\n         *    step 1  |  step 2  |  step 3  |  step 4\n         * --------------------------------------------\n         *    /       |  /       |  /       |  /\\  \n         *            |  \\       |  \\/      |  \\/\n         * --------------------------------------------\n         */\n\n        // begin\n        context.beginPath()\n        // move to start point\n        context.moveTo(v.top.x, v.top.y)\n        // define lines\n        context.lineTo(v.left.x, v.left.y)\n        context.lineTo(v.bottom.x, v.bottom.y)\n        context.lineTo(v.right.x, v.right.y)\n        context.lineTo(v.top.x, v.top.y)        \n        context.strokeStyle = 'black'\n\n        // draw path\n        context.stroke()\n    \n\n        // fill tile\n        // context.fillStyle = (this.highlight) ? '#ffff00' : color\n        // context.fill() \n    \n    }\n\n    private _drawMapPos() {\n\n        const { context } = this.map\n        const { x, y } = this.screenPos // topRight\n\n        context.fillStyle = 'black'\n        context.fillText( `${this.mapPos.x},${this.mapPos.y}`, x - 40, y + 20 )\n\n    }\n    private _drawTileRect( ) {\n\n        // Debug\n        const { context, tile: { width, height } } = this.map\n        const { topLeft: { x, y } } = this.map.getTileRect(this.screenPos)\n        context.beginPath()\n        context.rect( x, y, width, height)\n        context.stroke()\n\n    }\n}","\nimport { basename } from './iso.utils'\nimport { Tile } from './iso.tile'\n\n\nexport enum Direction {\n    NW, NE, SW, SE\n}\nexport type Position = {\n    x:number\n    y:number\n}\n\nexport type MapPosition = Position\nexport type ScreenPosition = Position\n\nexport type TileVertex = {\n    top:Position\n    left:Position\n    right:Position\n    bottom:Position\n}\n\nexport type TileRect = {\n    topRight:Position\n    topLeft:Position\n    bottomRight:Position\n    bottomLeft:Position\n}\n\nexport type Size = {\n    width:number\n    height:number\n}\n\nexport type MapParameters = {\n    screen:Size\n    mapSize:Size\n    tileSize:Size\n    canvasId?:string\n    color?:string\n}\n\nexport interface Entity {\n    \n    screenPos:ScreenPosition\n\n    render():void\n\n    compare( e:Entity ):number\n}\n\n/**\n * \n */\nexport abstract class BaseEntity implements Entity {\n\n    constructor( public screenPos:Position ) {}\n\n    abstract render(): void \n\n    compare(e: Entity): number {\n        const dy = this.screenPos.y - e.screenPos.y \n        if( dy === 0 ) {\n            return this.screenPos.x - e.screenPos.x\n        }\n        return dy\n    }\n\n}\n\nexport type Layer = 0 | 1 | 2\n\n/**\n * \n */\nexport class TileMap implements Entity {\n\n    private _canvas:HTMLCanvasElement\n    context:CanvasRenderingContext2D\n    screenPos:ScreenPosition = {x:0, y:0}\n\n    screenSize:Size\n    mapSize:Size\n    tile:Size & { color:string }\n\n    mapPos:MapPosition\n\n    renderLayers:[ Array<Entity>, Array<Entity>, Array<Entity> ] = [  [], [], [] ]\n\n    gameLoopItnterval?:NodeJS.Timer\n\n    images = new Map<string,HTMLImageElement>()\n\n    /**\n     * @desc constructor\n     * @param object $params - initial parameters\n     */\n    constructor(params:MapParameters) {\n\n        const canvas = document.getElementById(params.canvasId ?? 'canvas') as HTMLCanvasElement|null\n\n        if( canvas == null ) throw new Error(\"canvas is null!\")\n\n        \n        const context = canvas.getContext('2d')\n        if( context == null ) throw new Error(\"2d context from canvas is null!\")\n        \n        // canvas area details\n        this.screenSize =  { \n            width: params.screen.width,\n            height: params.screen.height\n        };\n\n        // set canvas size\n        canvas.setAttribute('width', `${this.screenSize.width}`);\n        canvas.setAttribute('height', `${this.screenSize.height}`);\n\n\n        // size of isometric map\n        this.mapSize = {\n            width: params.mapSize.width,\n            height: params.mapSize.height\n        };\n\n        // size of single tile\n        this.tile = {\n            width: params.tileSize.width,\n            height: params.tileSize.height,\n            color: params.color ?? '#15B89A'\n        }\n\n        // initial position of isometric map\n        this.mapPos = { x:this.screenSize.width / 2, y: this.tile.height * 2 }\n\n        this._canvas = canvas\n        this.context = context\n    \n    }\n\n    compare( e:TileMap ):number {\n        return 0\n    }\n\n    /**\n     * \n     */\n    get canvas():HTMLCanvasElement {\n        return this._canvas\n    }\n\n    /**\n     * \n     * @returns \n     */\n    clear = () => this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    \n    /**\n     * \n     * @param layer \n     */\n    addTiles( layer:Layer ) {\n        // tiles drawing loops\n        for (let x = 0; x < this.mapSize.width; x++) {\n            for ( let y = 0; y < this.mapSize.height; y++) {\n                this._addTile( {x:x, y:y }, layer )\n            }\n        }\n    }\n\n    /**\n     * \n     * @param fps \n     */\n    start( fps = 30 ) {\n        this.gameLoopItnterval = setInterval( () => this.render(), 1000/fps )\n    }\n\n    /**\n     * \n     */\n    render():void {\n        this.clear()\n\n        this.renderLayers[0]\n            .sort( ($1,$2) => $1.compare($2) )\n            .forEach( v =>  v.render() )\n\n        this.renderLayers[1]\n            .concat( this.renderLayers[2])\n            .sort( ($1,$2) => $1.compare($2) )\n            .forEach( v =>  v.render() )\n\n    }\n    \n    /**\n     * @desc add a single tile to a layer\n     * @param int $x - position x on canvas area\n     * @param int $y - position y on canvas area\n     * @param layer \n     */\n    private _addTile = ( map:MapPosition, layer:Layer ):Tile => {\n        const screen = this.convertIsoToScreen( map) \n        const result = new Tile( screen, map, this )\n        this.renderLayers[layer].push( result )\n        return result\n    }\n\n    /**\n     * \n     * @param layer \n     * @param predicate \n     * @returns \n     */\n    private  _findEntity<T extends Entity>( layer:Layer, predicate:( entity:Entity, index:number ) => boolean ):T|undefined {\n        return this.renderLayers[layer].find( predicate ) as T\n    }\n\n    /**\n     * \n     * @param screenPos \n     */\n    findTileByScreenPos( screenPos:ScreenPosition ) {\n        return this._findEntity<Tile>( 0, ( e, i ) => {\n\n            const isoPos = this.convertScreenToIso(screenPos)\n            const { mapPos } = e as Tile\n\n            return mapPos.x === isoPos.x && mapPos.y === isoPos.y \n\n        })\n    }\n\n    /**\n     * \n     * @param screenPos \n     */\n     findTileByIsoPos( isoPos:MapPosition, layer:Layer ) {\n        return this._findEntity<Tile>( layer, ( e, i ) => {\n\n            const { mapPos } = e as Tile\n\n            return mapPos.x === isoPos.x && mapPos.y === isoPos.y \n\n        })\n    }\n\n    /**\n     * add single prism to a layer\n     * @param x - position x on canvas area\n     * @param y - position y on canvas area\n     * @param layer \n     */\n    addEntity = <T extends Entity>( entity:T, layer:Layer ):boolean =>  {\n\n        const map = this.convertScreenToIso(entity.screenPos)\n\n        if( this.isOnMap(map) ) {\n            this.renderLayers[layer].push( entity )\n            return true\n\n        }\n\n        return false\n    }\n\n    /**\n     * \n     * @param screen \n     * @returns \n     */\n    convertScreenToIso( screen:ScreenPosition ):MapPosition {\n        \n        const x = (screen.x - this.mapPos.x) / this.tile.width\n        const y = (screen.y - this.mapPos.y) / this.tile.height\n\n        return { \n            x: Math.floor(y + x), \n            y: Math.floor(y - x)  \n        }\n    }\n\n    /**\n     * \n     * @param map \n     * @returns \n     */\n    convertIsoToScreen = ( map:MapPosition ):ScreenPosition  => ({\n            x: ( (map.x-map.y) * this.tile.width / 2 ) + this.mapPos.x,\n            y: ( (map.x+map.y) * this.tile.height / 2 ) + this.mapPos.y\n        })\n\n    /**\n     * \n     * @param pos \n     * @returns \n     */\n     getTileVertex = (pos:ScreenPosition):TileVertex => ({\n        top:    { x: pos.x - this.tile.width / 2, y: pos.y  },\n        left:   { x: pos.x - this.tile.width, y: pos.y + this.tile.height / 2 },\n        right:  { x: pos.x, y: pos.y + this.tile.height / 2 },\n        bottom: { x: pos.x - this.tile.width / 2, y: pos.y + this.tile.height }\n    })\n\n    /**\n     * \n     * @param pos \n     * @returns \n     */\n    getTileRect = (pos:ScreenPosition):TileRect => ({\n            topRight:       pos,\n            bottomLeft:     { x: pos.x - this.tile.width, y: pos.y + this.tile.height },\n            bottomRight:    { x:pos.x, y: pos.y + this.tile.height },\n            topLeft:        { x: pos.x - this.tile.width, y: pos.y }\n        })\n\n    /**\n     * \n     * @param position \n     * @returns \n     */\n    isOnMap = (position:MapPosition):boolean  => \n            (position.x >= 0 && position.x < this.mapSize.width \n                && position.y >= 0 && position.y < this.mapSize.height) \n\n\n    /**\n     * \n     * @param path \n     * @returns \n     */\n    loadImages( ...paths: string[] ):Promise<void>  {\n        return Promise.all(paths.map( path => loadImage(path) )).then((values) => {\n            values\n                .filter( v => v!=null )\n                .forEach( v => this.images.set( v!.name, v!.img) )\n\n        });\n    }\n    \n    renderImageScaled(basename:string, screenPos:ScreenPosition, toSize:Size) {\n        const img = this.images.get( basename )\n\n        if( img ) {\n            const hRatio = toSize.width  / img.width    ;\n            const vRatio =  toSize.height / img.height  ;\n            const ratio  = Math.min ( hRatio, vRatio );\n\n            const { bottomLeft: {x, y} } = this.getTileRect(screenPos)\n            this.context.drawImage( \n                img, \n                0, 0,  \n                img.width, img.height,\n                x, y - toSize.height,\n                img.width*ratio, img.height*ratio\n                )    \n\n        }\n\n        //\n        // @ref https://stackoverflow.com/a/23105310\n        //\n        // var canvas = ctx.canvas ;\n        // var hRatio = canvas.width  / img.width    ;\n        // var vRatio =  canvas.height / img.height  ;\n        // var ratio  = Math.min ( hRatio, vRatio );\n        // var centerShift_x = ( canvas.width - img.width*ratio ) / 2;\n        // var centerShift_y = ( canvas.height - img.height*ratio ) / 2;  \n        // ctx.clearRect(0,0,canvas.width, canvas.height);\n        // ctx.drawImage(img, 0,0, img.width, img.height,\n        //                    centerShift_x,centerShift_y,img.width*ratio, img.height*ratio);  \n     } \n\n    /**\n     * \n     * @param basename \n     * @param screenPos \n     */\n    renderImage( basename:string, screenPos:ScreenPosition ):void {\n        const source = this.images.get( basename )\n\n        if( source ) {\n            const { bottomLeft: {x, y} } = this.getTileRect(screenPos)\n            this.context.drawImage( source, x, y - source!.naturalHeight )    \n        }\n    }\n\n    /**\n     * \n     * @param screenPos \n     * @param dir \n     * @param layer \n     * @param filter \n     * @returns \n     */\n    checkCollision( screenPos:ScreenPosition, dir:Direction, layer:Layer, filter?:(e:Entity) => boolean):boolean {\n\n        const entities = (filter) ? \n                        this.renderLayers[layer].filter( filter ) : \n                        this.renderLayers[layer]\n\n        const vt = this.getTileVertex(screenPos)\n\n        let predicate:((e:Entity) => boolean)|undefined\n\n        // console.log( 'collision', dir )\n        switch( dir ) {\n        case Direction.SW:\n        case Direction.SE:\n            predicate = ( e ) => {\n                const { top, left } = this.getTileVertex(e.screenPos)\n                const { x,y } = vt.left\n\n                // console.log( vt.left, 'top', top, 'left', left )\n                return ( x < top.x && x >= left.x ) &&\n                       ( y > top.y && y <= left.y)\n            }\n            break\n        case Direction.NW:\n        case Direction.NE:\n            predicate = ( e ) => {\n                const { bottom, right } = this.getTileVertex(e.screenPos)\n                const { x,y } = vt.right\n\n                // console.log( vt.right, 'bottom', bottom, 'right', right )\n                return ( x > bottom.x && x <= right.x ) &&\n                       ( y < bottom.y && y >= right.y)\n            }\n            break\n        }\n\n        return ( predicate ) ?\n            entities.find( predicate )!==undefined : false\n    }\n\n}\n\nfunction loadImage( path:string ):Promise<{ name:string, img:HTMLImageElement}|null> {\n    const name = basename(path)\n    if( !name ) {\n        console.warn( `image path: ${path} is not valid!` )\n        return Promise.resolve( null )\n    }\n\n    return new Promise( (resolve, _) => {\n        let result = new Image()\n        result.onload = ( event:any ) => {\n            console.log( `image ${name} from path: ${path} loaded`, event )\n            resolve( { name:name, img:result} )\n        }\n        result.onerror = ( err:any ) => {\n            console.warn( `error loading image path: ${path}`, err )\n            resolve(null)\n        }\n        result.onabort = ( err:any ) => {\n            console.warn( `abort loading image path: ${path}`, err )\n            resolve(null)\n        }\n        result.src = path\n    \n    })\n\n}\n\n\n","import { Entity, ScreenPosition, MapPosition, TileMap, BaseEntity, Direction } from './iso'\n\ntype ImageSet = 'man-se'|'man-sw'|'man-ne'|'man-nw'\n\nexport class Person extends BaseEntity {\n\n    move:Direction|null = null\n    currentImage:ImageSet = 'man-se'\n\n    constructor( public mapPos:MapPosition, private map:TileMap) {\n        super( map.convertIsoToScreen( mapPos ) )\n    }\n\n    compare( e:Person ):number {\n        \n        const dy = this.screenPos.y - e.screenPos.y \n        if( dy === 0 ) {\n            return this.screenPos.x - e.screenPos.x\n        }\n        return dy\n    }\n\n    private _moveTo( dir:Direction, _mapPos:MapPosition, image:ImageSet) {\n        if( this.map.isOnMap( _mapPos ) ){\n            this.currentImage = image\n\n            const _screenPos = this.map.convertIsoToScreen( _mapPos )\n\n            if( !this.map.checkCollision( _screenPos, dir, 1 ) ) {\n                this.mapPos     = _mapPos\n                this.screenPos  = _screenPos\n            }\n        }\n\n    }\n\n    render():void {\n\n        switch( this.move ) {\n            case Direction.SE:\n                this._moveTo( Direction.SE, { x:this.mapPos.x + 1, y:this.mapPos.y }, 'man-se')\n                break\n            case Direction.SW:\n                this._moveTo( Direction.SW, { x:this.mapPos.x,y:this.mapPos.y+1}, 'man-sw')\n                break\n            case Direction.NE:\n                this._moveTo( Direction.NE, { x:this.mapPos.x,y:this.mapPos.y-1 }, 'man-ne')\n                break\n            case Direction.NW:\n                this._moveTo( Direction.NW, { x:this.mapPos.x-1,y:this.mapPos.y }, 'man-nw')\n                break\n\n        }\n        this.map.renderImage(this.currentImage, this.screenPos )\n        \n    }\n}","import { ScreenPosition } from \"./iso\";\n\nexport type KeyBoardValue = 'ArrowLeft'|'ArrowUp'|'ArrowRight'|'ArrowDown'\n\n\nclass Key {\n    isDown = false;\n    isUp = true;\n    press?:() => void\n    release?: () => void\n    unsubscribe:() => void\n\n    constructor( private value:KeyBoardValue, target:EventTarget ) {\n\n        const downHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isUp && this.press) this.press()\n              this.isDown = true\n              this.isUp = false\n              event.preventDefault()\n            }\n          }\n        \n        const upHandler = (event:KeyboardEvent) => {\n            if (event.key === this.value) {\n              if (this.isDown && this.release) this.release()\n              this.isDown = false\n              this.isUp = true\n              event.preventDefault()\n            }\n          }\n        \n        target.addEventListener( 'keydown', downHandler as EventListener, false )\n        target.addEventListener( 'keyup', upHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'keydown', downHandler as EventListener, false )\n            target.removeEventListener( 'keyup', upHandler as EventListener, false )\n    \n        }\n    }\n\n\n  \n}\n\nexport class Mouse {\n    press?:( event:MouseEvent ) => void\n    up?: ( event:MouseEvent ) => void\n    move?: ( event:MouseEvent ) => void\n\n    unsubscribe:() => void\n\n    constructor( target:Element ) {\n\n        const downHandler = (event:MouseEvent) => {\n            if (this.press) this.press(event)\n            event.preventDefault()\n        }\n        \n        const upHandler = (event:MouseEvent) => {\n            if (this.up) this.up(event)\n            event.preventDefault()\n        }\n\n        const moveHandler = (event:MouseEvent) => {\n          if (this.move) this.move(event)\n          event.preventDefault()\n        }\n        \n        target.addEventListener( 'mousedown', downHandler as EventListener, false )\n        target.addEventListener( 'mouseup', upHandler as EventListener, false )\n        target.addEventListener( 'mousemove', moveHandler as EventListener, false )\n    \n        this.unsubscribe = () => {\n            target.removeEventListener( 'mousedown', downHandler as EventListener, false )\n            target.removeEventListener( 'mouseup', upHandler as EventListener, false )\n            target.removeEventListener( 'mousemove', moveHandler as EventListener, false )\n        }\n\n        \n    }  \n\n    /**\n    * \n    * @param event \n    * @returns \n    */\n    getMousePosition(event:MouseEvent):ScreenPosition|null {\n      const elem = event.target as Element|null;\n\n      if( elem == null ) return null\n\n      const rect = elem.getBoundingClientRect()\n\n      return {\n          x: event.clientX - rect.left,\n          y: event.clientY - rect.top\n      }\n  }\n\n}\n\nexport const keyboard = ( value:KeyBoardValue, target:EventTarget = document ) => (new Key(value, target))\nexport const mouse = ( target:Element ) => (new Mouse(target))\n","\nimport { BaseEntity, ScreenPosition, TileMap } from './iso'\n\nexport class Image extends BaseEntity {\n\n    constructor(  private basename:string, screenPos:ScreenPosition, private map:TileMap) {\n        super(screenPos)\n    }\n\n    render():void {\n        this.map.renderImage( this.basename, this.screenPos )\n    }\n\n\n}","import { Direction, MapParameters, TileMap } from './iso'\nimport { Tile } from './iso.tile'\nimport { Prism } from './iso.prism'\nimport { Person } from './iso.person'\nimport { keyboard, mouse } from './iso.input' \nimport { Image as Img } from './iso.image'\n\n// isometric map settings\nconst params:MapParameters = {\n    screen: { width: 1024*2, height: 800*2 },\n    mapSize: { width: 14, height: 14 },\n    tileSize: { width: 64, height: 32 }\n}\n\nconst outDiv = document.getElementById('debug')\n\nconst TILE_LAYER = 0 \nconst PRISM_LAYER = 1\nconst PERSON_LAYER = 2\n\n// create map\nconst isoMap = new TileMap(params);\nisoMap.loadImages( \n    'assets/man-ne.png', \n    'assets/man-nw.png', \n    'assets/man-se.png',\n    'assets/man-sw.png',\n    'assets/tiles/grass01.png',\n    'assets/tiles/rock.png',\n    'assets/tiles/snow.png',\n    'assets/tiles/brickpavers2.png',\n    'assets/tiles/cretebrick970.png',\n    'assets/wall-low-single.png'\n    ).then( start )\n\nfunction start() {\n    isoMap.addTiles( TILE_LAYER );\n    isoMap.start()\n\n    let left = keyboard(\"ArrowLeft\"),\n        up = keyboard(\"ArrowUp\"),\n        right = keyboard(\"ArrowRight\"),\n        down = keyboard(\"ArrowDown\");\n\n    // const _mouse = mouse( isoMap.canvas )\n    const _mouse = mouse( document.body )\n\n    _mouse.press =  (event) => {\n            let pos = _mouse.getMousePosition(event)\n\n            if( pos != null ) {\n\n                pos = isoMap.convertScreenToIso(pos) // adjust position on map\n\n                isoMap.addEntity( new Img( 'wall-low-single', isoMap.convertIsoToScreen( pos ) , isoMap), PRISM_LAYER )\n           \n                //isoMap.addEntity( new Prism( isoMap.convertIsoToScreen( pos ), isoMap), PRISM_LAYER )\n            }\n    }\n\n    let lastTile:Tile|undefined\n\n    _mouse.move = (event) => {\n        const mousepos = _mouse.getMousePosition(event)\n\n        if( mousepos != null ) {\n\n            const pos = isoMap.convertScreenToIso(mousepos) // adjust position on map\n        \n            outDiv!.innerHTML = `[${mousepos.x},${mousepos.y}] - [${pos.x},${pos.y}]`\n            const tile = isoMap.findTileByIsoPos(pos, TILE_LAYER)\n\n            if( tile ) {\n                if( lastTile ) {\n                    lastTile.highlight = false\n                }\n                //console.log( `${tile.mapPos.x},${tile.mapPos.y}`)\n                lastTile = tile \n                lastTile.highlight = true\n            }\n        }\n    }\n\n    // const img = new ImageEntity('man-ne', isoMap.convertIsoToScreen( {x:1, y:0} ), isoMap )\n    // isoMap.addEntity( img )\n\n    const person = new Person(  {x:1, y:1}, isoMap )\n\n    isoMap.addEntity( person, PERSON_LAYER )\n\n    const release = () => person.move = null\n\n    left.press = () => person.move = Direction.SW \n    right.press = () => person.move = Direction.NE\n    up.press = () => person.move = Direction.NW\n    down.press = () => person.move = Direction.SE\n\n    left.release = release\n    right.release = release\n    down.release = release\n    up.release = release\n\n}","/**\n * \n * @param path \n * @returns \n */\nexport const basename = ( path:string ):string|undefined => {\n    const elem = path.split(\"/\")\n    if( elem.length > 0 ) {\n        const last = elem[ elem.length - 1]\n        const result = /(.+)[.](.+)$/.exec(last)    \n        if( result != null ) {\n            return result[1]\n        }\n    }\n} \n    \n"],"names":["$8c16fa1d59734288940dd6104ed4bcc0$export$4cbd7057afcc19d","screenPos","mapPos","map","highlight","compare","e","render","context","this","save","_renderLines","_drawTileRect","_drawMapPos","restore","_renderImage","renderImageScaled","tile","v","getTileVertex","color","beginPath","moveTo","top","x","y","lineTo","left","bottom","right","strokeStyle","stroke","fillStyle","fillText","width","height","topLeft","getTileRect","rect","Direction","$4a34614f6163d09f68bba6ca66a67f19$export$96381b1a7f788138","$4a34614f6163d09f68bba6ca66a67f19$export$a4604b21441a2505","screenPos1","dy","$74a951b6da4693c1c15d3599f73920bd$export$26a0dba5ba1fe6f5","super","convertIsoToScreen","move","currentImage","_moveTo","dir","_mapPos","image","isOnMap","_screenPos","checkCollision","SE","SW","NE","NW","renderImage","$f7a0ca685fc15ff0733c8744dc854746$var$Key","value","target","isDown","isUp","downHandler","event","key","press","preventDefault","upHandler","release","addEventListener","unsubscribe","removeEventListener","$f7a0ca685fc15ff0733c8744dc854746$export$1e7d889471c16c64","target1","downHandler1","upHandler1","up","moveHandler","getMousePosition","elem","getBoundingClientRect","clientX","clientY","$f7a0ca685fc15ff0733c8744dc854746$export$ea6328a15d7d48c9","value1","target2","document","$13d44aabde638f8f46a917dfd7a84e57$export$4635d5d3d3ce5bc7","basename","$a4018e003ec9cbe06ab0cc0137aa4e69$var$outDiv","getElementById","$a4018e003ec9cbe06ab0cc0137aa4e69$var$isoMap","constructor","params","renderLayers","images","Map","clear","clearRect","canvas","_addTile","layer","screen","result","push","addEntity","entity","convertScreenToIso","pos","topRight","bottomLeft","bottomRight","position","mapSize","canvasId","Error","getContext","screenSize","setAttribute","tileSize","_canvas","addTiles","start","fps","gameLoopItnterval","setInterval","sort","$1","$2","forEach","concat","_findEntity","predicate","find","findTileByScreenPos","i","isoPos","findTileByIsoPos","Math","floor","loadImages","paths","Promise","all","path","name","split","length","last","exec","$04b7f286a5ed5d84632c73262f84779c$export$6aeba2462e8c6a4","console","warn","resolve","_","Image","onload","log","img","onerror","err","onabort","src","$4a34614f6163d09f68bba6ca66a67f19$var$loadImage","then","values","filter","set","toSize","get","hRatio","vRatio","ratio","min","drawImage","source","naturalHeight","entities","vt","undefined","down","_mouse","body","lastTile","mousepos","innerHTML","person"],"version":3,"file":"index.93e8f5cf.js.map"}